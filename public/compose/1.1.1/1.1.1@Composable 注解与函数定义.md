
### 1. 核心理论：从“命令”到“描述”

#### 1.1 什么是 @Composable？
在学习 Compose 之前，你可能习惯了使用 XML 定义布局，然后在 Java/Kotlin 代码中找到它并修改它。那是一种**命令式**的思维：你像一个工头，指挥系统“去把那个 TextView 的文字改成 Hello”。

Jetpack Compose 采用了**声明式**思维。`@Composable` 注解就是这个新世界的入口。

你可以把添加了 `@Composable` 的函数想象成一张**蓝图**或**说明书**。
*   **普通函数**：执行一个动作（例如：计算 `1+1`，或者把数据存入数据库）。
*   **Composable 函数**：描述一个界面（例如：“屏幕上应该有一个显示名字的文本框”）。

当你在函数头上加上 `@Composable` 时，你实际上是在告诉编译器：“**这是一个用于描述 UI 的函数**，请给它赋予绘制界面的能力。”

#### 1.2 为什么不能有返回值？
这是初学者最困惑的地方。看下面的对比：

**传统 View 方式（伪代码）：**
```kotlin
fun createTextView(context: Context): TextView {
    val view = TextView(context)
    view.text = "Hello"
    return view // 返回了一个具体的对象，你需要拿着这个对象去添加到父布局里
}
```

**Compose 方式：**
```kotlin
@Composable
fun Greeting() {
    Text(text = "Hello") // 没有返回值！
}
```

**深度解析**：
Compose 函数不返回 UI 控件对象，因为**它直接在执行过程中“发射”了 UI 数据**。
想象一下你在指挥一个画家。
*   传统方式是你做好了画框交给画家。
*   Compose 方式是你站在画家旁边说：“这里画一个圆，那里涂成红色。”你说完这句话，画就已经出现在画布上了。你不需要“返回”那个圆，因为圆已经存在于画布（UI 树）之中了。
因此，Composable 函数的返回值通常是 `Unit`（即没有返回值）。

#### 1.3 编译器背后的工作（隐式传参）
为什么普通函数不能调用 Composable 函数？
```kotlin
// 错误示例
fun onUserLogin() {
    Greeting() // 报错！
}
```

**原理详解**：
这就好比“在没有画布的地方没法画画”。
当你在代码中写下 `@Composable` 时，Kotlin 编译器会在编译期间悄悄修改你的函数签名。它会向函数列表中添加一个隐藏的参数，通常被称为 `Composer`。

*   **你写的代码**：`fun Greeting()`
*   **编译器眼中的代码**：`fun Greeting(composer: Composer)`

这个 `composer` 就是那个“画布上下文”。它负责记录你描述了什么 UI。
*   **普通函数**没有这个 `composer` 参数，所以它无法把它传递给 `Greeting`。
*   **Composable 函数**拥有这个隐式参数，所以它可以把它传递给内部调用的其他 Composable 函数。

这就是**调用上下文限制**的根本原因：上下文（Context）必须在调用链中一路传递下去。



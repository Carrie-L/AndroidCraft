这是 **2.4.1 单向数据流模式 (Unidirectional Data Flow - UDF)** 的详细知识讲解。

很多初学者学到这里会觉得：“既然 `remember` 这么好用，我把所有状态都塞在组件内部不就好了？”
**千万别！** 这就是混乱的开始。这一节我们将学习 Compose 最核心的架构思想 —— **UDF**。搞懂了它，你的代码才算真正的“架构整洁”。

---

# 2.4.1 单向数据流模式 (Unidirectional Data Flow - UDF)

## 1. 核心理论：数据与事件的单行道

### 1.1 混乱的双向流 (The Chaos of Bidirectional)
在传统的 View 开发中，经常出现这种情况：
*   Activity 修改了 CheckBox 的状态 `checkBox.setChecked(true)`。
*   CheckBox 用户点击了，自己变了，然后回调 Listener 通知 Activity。
*   Listener 里又写逻辑去修改 CheckBox...
这种状态分散在 UI 控件内部和 Activity 逻辑中的模式，容易导致**状态同步冲突**（比如：UI 显示选中了，但数据模型里还是未选中）。

### 1.2 什么是单向数据流 (UDF)？
UDF 规定了数据和事件只能沿**各自唯一的方向**流动，形成一个闭环：

1.  **State Flow Down (状态下行)**：
    *   父组件（或 ViewModel）持有数据。
    *   数据通过**参数**传给子组件。
    *   子组件只负责展示，**绝对不修改数据**。

2.  **Event Flow Up (事件上行)**：
    *   子组件发生交互（如点击）。
    *   子组件通过**Lambda 回调**通知父组件。
    *   父组件接收事件，修改数据源。

**结果**：数据源一变，自动再次下行刷新子组件 UI。**数据永远只有一份真理 (Single Source of Truth)**。

### 1.3 为什么这么做？
*   **可测试性**：子组件变成了纯粹的 UI 渲染器，没有业务逻辑，给它什么它画什么，极其好测。
*   **解耦**：子组件不需要知道“点击后要存数据库还是发网络请求”，它只管喊一声“我被点了”。
*   **排错容易**：如果数据错了，肯定是上游给错了，不用去子组件内部找 Bug。

---

## 2. 知识测验 (Quiz)

### 问题 1 [架构辨析]
请看下面的代码，它违反了 UDF 原则吗？

```kotlin
@Composable
fun MySwitch(state: MutableState<Boolean>) { // 接收一个可变状态对象
    Switch(
        checked = state.value,
        onCheckedChange = { 
            state.value = it // <--- 子组件直接修改了传进来的状态对象
        }
    )
}
```

A. 没有违反，这是正常的写法。
B. 违反了。子组件直接修改了父组件传递的对象。应该把 `state` 拆分为 `checked: Boolean` 和 `onCheckChange: (Boolean) -> Unit`。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：虽然代码能跑，但它破坏了封装性。子组件“越权”修改了数据。
> *   **正规写法**：`fun MySwitch(checked: Boolean, onCheckChange: (Boolean) -> Unit)`。
> *   这样子组件就变成了一个**无状态 (Stateless)** 组件，完全受控于父组件。

### 问题 2 [数据流向]
在 UDF 模式中，如果用户在输入框打字，数据流动的正确路径是：

A. 输入框内部更新显示 -> 通知 ViewModel -> ViewModel 更新数据。
B. 输入框回调 Event -> ViewModel 更新 State -> State 下发给输入框 -> 输入框刷新显示。

> **答案：B**
> **解析**：**输入框自己是不会更新显示的！** 在 Compose 中，如果你不把新的 State 传回给 TextField，无论你怎么打字，输入框里都不会出现新字符。这体现了“UI 是状态的投影”。

---

## 3. 编码实战 (Code Lab)

**任务目标**：实现一个标准的 UDF 组件 —— “受控开关 (Controlled Toggle)”。

### 步骤 1：编写无状态子组件
这个组件自己没有 `remember`，完全听命于人。

```kotlin
@Composable
fun ControlledSwitch(
    isChecked: Boolean,           // 1. 状态下行
    onToggle: (Boolean) -> Unit   // 2. 事件上行
) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Text(if (isChecked) "已开启" else "已关闭")
        Spacer(modifier = Modifier.width(8.dp))
        Switch(
            checked = isChecked,
            onCheckedChange = onToggle // 将 Switch 的内部事件转发出去
        )
    }
}
```

### 步骤 2：编写管理状态的父组件
父组件持有“唯一可信源”。

```kotlin
@Composable
fun UDFScreen() {
    // 数据源在这里
    var switchState by remember { mutableStateOf(false) }

    Column(modifier = Modifier.padding(16.dp)) {
        Text("控制面板", style = MaterialTheme.typography.headlineSmall)
        
        // 调用子组件
        ControlledSwitch(
            isChecked = switchState, // 传数据
            onToggle = { newState -> 
                // 处理事件：修改数据源
                switchState = newState
                println("状态更新为: $newState")
            }
        )
        
        // 证明数据源确实变了
        Text("Debug: 父组件存储的值是 $switchState")
    }
}
```

### 步骤 3：运行与验证
1.  运行 App。
2.  点击 Switch。
3.  **流程验证**：
    *   Switch 触发 `onCheckedChange`。
    *   调用 `onToggle`。
    *   父组件 `switchState` 变为 true。
    *   父组件重组，再次调用 `ControlledSwitch(isChecked = true)`。
    *   界面显示为“已开启”且 Switch 滑块变绿。

这就是完美的 UDF 闭环。
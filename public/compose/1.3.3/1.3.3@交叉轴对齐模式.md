这是 **1.3.3 交叉轴对齐模式 (Alignment Modes)** 的详细知识讲解。

刚才我们学会了怎么在主轴上“分蛋糕”，现在要学习怎么在交叉轴上“站队”。这是决定元素**重心**的关键一步。

---

# 1.3.3 交叉轴对齐模式 (Alignment Modes)

## 1. 核心理论：重心的偏移

### 1.1 什么是对齐？
在主轴上，我们关注的是**分布 (Arrangement)**，也就是元素之间的距离。
在交叉轴上，子元素通常只有一行（或一列），所以我们只关注它们相对于容器的**偏向 (Alignment)**。

**举个例子**：
在一个高度为 200dp 的 `Row` 里，放一个高度只有 50dp 的文字。
*   文字是靠上 (Top)？
*   居中 (CenterVertically)？
*   还是靠下 (Bottom)？

这就是 `Alignment` 决定的事。

### 1.2 对齐的作用域
Alignment 有两个维度，不同容器能用的属性不一样，这是编译器会帮你检查的，但原理你要懂：

*   **Row 的交叉轴是 Y 轴** -> 所以只能用 `Vertical` 相关的对齐。
    *   `Alignment.Top`
    *   `Alignment.CenterVertically`
    *   `Alignment.Bottom`

*   **Column 的交叉轴是 X 轴** -> 所以只能用 `Horizontal` 相关的对齐。
    *   `Alignment.Start` (左)
    *   `Alignment.CenterHorizontally`
    *   `Alignment.End` (右)

### 1.3 两种设置方式：整体 vs 个体
这是 Compose 布局系统非常灵活的一个设计：

1.  **容器级设置 (Container Level)**：
    *   在 `Row` 或 `Column` 的参数里设置。
    *   **作用**：控制**所有**子元素的默认对齐方式。
    *   *代码*：`Row(verticalAlignment = Alignment.CenterVertically)`

2.  **修饰符级设置 (Modifier Level)**：
    *   在子元素自己的 `Modifier` 里设置。
    *   **作用**：覆盖默认设置，让**这个**子元素特立独行。
    *   *代码*：`Text(modifier = Modifier.align(Alignment.Bottom))`

**为什么需要“个体设置”？**
想象一个聊天列表项：
*   左边是头像。
*   中间是名字。
*   右边是一个时间。
通常头像和名字是垂直居中的，但**时间可能需要靠右上角对齐**。这时候就需要给时间单独设置 `align(Top)`。

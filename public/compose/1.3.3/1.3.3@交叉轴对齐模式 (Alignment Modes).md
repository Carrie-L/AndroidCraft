这是 **1.3.3 交叉轴对齐模式 (Alignment Modes)** 的详细知识讲解。

刚才我们学会了怎么在主轴上“分蛋糕”，现在要学习怎么在交叉轴上“站队”。这是决定元素**重心**的关键一步。

---

# 1.3.3 交叉轴对齐模式 (Alignment Modes)

## 1. 核心理论：重心的偏移

### 1.1 什么是对齐？
在主轴上，我们关注的是**分布 (Arrangement)**，也就是元素之间的距离。
在交叉轴上，子元素通常只有一行（或一列），所以我们只关注它们相对于容器的**偏向 (Alignment)**。

**举个例子**：
在一个高度为 200dp 的 `Row` 里，放一个高度只有 50dp 的文字。
*   文字是靠上 (Top)？
*   居中 (CenterVertically)？
*   还是靠下 (Bottom)？

这就是 `Alignment` 决定的事。

### 1.2 对齐的作用域
Alignment 有两个维度，不同容器能用的属性不一样，这是编译器会帮你检查的，但原理你要懂：

*   **Row 的交叉轴是 Y 轴** -> 所以只能用 `Vertical` 相关的对齐。
    *   `Alignment.Top`
    *   `Alignment.CenterVertically`
    *   `Alignment.Bottom`

*   **Column 的交叉轴是 X 轴** -> 所以只能用 `Horizontal` 相关的对齐。
    *   `Alignment.Start` (左)
    *   `Alignment.CenterHorizontally`
    *   `Alignment.End` (右)

### 1.3 两种设置方式：整体 vs 个体
这是 Compose 布局系统非常灵活的一个设计：

1.  **容器级设置 (Container Level)**：
    *   在 `Row` 或 `Column` 的参数里设置。
    *   **作用**：控制**所有**子元素的默认对齐方式。
    *   *代码*：`Row(verticalAlignment = Alignment.CenterVertically)`

2.  **修饰符级设置 (Modifier Level)**：
    *   在子元素自己的 `Modifier` 里设置。
    *   **作用**：覆盖默认设置，让**这个**子元素特立独行。
    *   *代码*：`Text(modifier = Modifier.align(Alignment.Bottom))`

**为什么需要“个体设置”？**
想象一个聊天列表项：
*   左边是头像。
*   中间是名字。
*   右边是一个时间。
通常头像和名字是垂直居中的，但**时间可能需要靠右上角对齐**。这时候就需要给时间单独设置 `align(Top)`。

---

## 2. 知识测验 (Quiz)

### 问题 1 [代码纠错]
你想让一个 `Column` 里的文字**水平居中**。你写了如下代码，但报错了。请指出原因。

```kotlin
// 错误代码
Column {
    Text(
        "Hello",
        modifier = Modifier.align(Alignment.CenterVertically) // <--- 报错
    )
}
```

A. `align` 只能用于 `Box`。
B. `Column` 的交叉轴是水平方向，应该用 `CenterHorizontally`，而 `CenterVertically` 是用于 `Row` 的。
C. 应该用 `Arrangement.Center`。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：
> *   `Column` 是竖着排的。
> *   它的交叉轴（侧面）是**水平方向**。
> *   所以它的 `ColumnScope` 只提供了 `align(Alignment.Horizontal)` 类型的修饰符。
> *   你试图给它一个 `Vertical` 的对齐，类型不匹配，编译器直接报错。

### 问题 2 [优先级判断]
如果 `Row` 设置了 `verticalAlignment = Alignment.Top`，但其中一个子元素 `Text` 设置了 `Modifier.align(Alignment.Bottom)`。最终这个 Text 会在哪里？

A. 顶部 (Top)
B. 底部 (Bottom)
C. 居中 (Center)

> **答案：B**
> **解析**：**子元素的 Modifier 优先级 > 父容器的默认设置**。这就是“特立独行”的规则。

---

## 3. 编码实战 (Code Lab)

**任务目标**：制作一个“垂直居中”的列表项，但让其中一个元素“沉底”。

我们需要这样一个 `Row`（高度固定为 100dp）：
1.  左边：一个红色方块，垂直居中。
2.  中间：一个绿色方块，垂直居中。
3.  右边：一个蓝色方块，**靠下对齐**。

### 步骤 1：设置容器
创建一个固定高度的 `Row`，并设置**默认垂直居中**。

```kotlin
@Composable
fun AlignmentLab() {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp) // 给容器一个高度，否则看不出对齐效果
            .background(Color.LightGray),
        // 1. 容器级设置：默认大家都居中
        verticalAlignment = Alignment.CenterVertically
    ) {
        // 稍后填入方块
    }
}
```

### 步骤 2：添加子元素
填入三个方块。前两个跟随大部队（居中），第三个单独设置对齐。

```kotlin
@Composable
fun AlignmentLab() {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp)
            .background(Color.LightGray),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // 红色：跟随默认（居中）
        Box(modifier = Modifier.size(40.dp).background(Color.Red))
        
        Spacer(modifier = Modifier.width(10.dp))

        // 绿色：跟随默认（居中）
        Box(modifier = Modifier.size(40.dp).background(Color.Green))

        Spacer(modifier = Modifier.width(10.dp))

        // 蓝色：特立独行（靠底）
        Box(
            modifier = Modifier
                .size(40.dp)
                .background(Color.Blue)
                .align(Alignment.Bottom) // 2. 修饰符级设置：覆盖默认，改为靠底
        )
    }
}
```

### 步骤 3：运行与观察
你会看到：
*   灰色背景条高度为 100dp。
*   红、绿方块悬浮在中间。
*   蓝色方块趴在灰色条的底部边缘。

这就是 **Alignment** 的精髓：**默认规则 + 个体覆盖**，让你能处理各种不对称的 UI 设计。
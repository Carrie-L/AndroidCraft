

# 2.3.1 remember 函数 (Positional Memoization)

## 1. 核心理论：给函数装个“脑子”

### 1.1 函数的“失忆症”
Composable 函数本质上就是 Kotlin 函数。
回想一下普通函数：
```kotlin
fun calculate() {
    val a = 10 // 局部变量
    println(a)
}
```
每次你调用 `calculate()`，变量 `a` 都会被**重新创建**成 10。函数执行完，`a` 就被回收了。
哪怕你把它改成 `var a = Random.nextInt()`，下次调用时，它又是一个新的随机数。**它记不住上次的值。**

在 Compose 中，重组 = 重新调用函数。
如果你直接写 `var count = mutableStateOf(0)`：
1.  第一次渲染：创建 count (0)。
2.  点击按钮，count 变 1。触发重组。
3.  第二次渲染（重组）：**重新执行这行代码** -> 创建一个新的 count (0)。
4.  **结果**：你的计数器永远卡在 0，或者瞬间闪回 0。

### 1.2 `remember` 的作用
`remember` 是一个特殊的 API，它利用了 Compose 的 **位置记忆 (Positional Memoization)** 机制。

当你写下：
```kotlin
val count = remember { mutableStateOf(0) }
```
Compose 编译器和运行时会配合做这几件事：
1.  **初次见面**：这是我第一次在代码的**第 X 行**看到 `remember` 吗？
    *   如果是：执行 `{ }` 里的代码（创建 0），并把它**存入 Slot Table 的特定格子里**。
2.  **再次重逢（重组）**：我又执行到了**第 X 行**的 `remember`。
    *   我不执行 `{ }` 了。
    *   我直接从 Slot Table 的那个格子里，把上次存的对象拿出来给你。

这就是为什么它叫 `remember` —— 它让函数拥有了记忆力，能跨越重组保留数据。

### 1.3 remember 的生命周期
记忆不是永久的。
*   **忘记 (Forget)**：如果这个 Composable 从 UI 树上**移除了**（比如 `if (false) MyScreen()`），那么它在 Slot Table 里占用的格子就会被清空。
*   **带 Key 的记忆**：`remember(key) { ... }`。
    *   如果 `key` 变了（比如传入的用户 ID 变了），Compose 就会认为“这是个新情况”，于是清空旧记忆，重新执行 `{ }` 初始化新值。

---

## 2. 知识测验 (Quiz)

### 问题 1 [场景判断]
```kotlin
@Composable
fun SearchScreen() {
    // 随机生成一个搜索 ID
    val searchId = remember { UUID.randomUUID().toString() }
    
    Text("Search ID: $searchId")
}
```
如果 `SearchScreen` 所在的父组件发生了重组（但 `SearchScreen` 依然显示在屏幕上），屏幕上的 UUID 会变吗？

A. 会变，每次重组都会生成新的。
B. 不会变，remember 记住了第一次生成的值。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：只要 `SearchScreen` 没有从屏幕上消失（移除），`remember` 就会一直返回最初存储的那个 UUID。

### 问题 2 [逻辑陷阱]
```kotlin
@Composable
fun UserProfile(userId: String) {
    // 我们希望根据 userId 加载数据，如果 userId 变了，user 应该重置
    val user = remember { loadUser(userId) } // <--- 问题代码
    ...
}
```
如果 `userId` 从 "A" 变成了 "B"，`user` 变量会更新吗？

A. 会更新，因为参数变了。
B. 不会更新，`remember` 代码块只会执行一次。

> **答案：B**
> **解析**：无参的 `remember { }` **只在进入组合时执行一次**。后续无论参数怎么变，它都直接返回缓存值（也就是 User A）。
> *修正*：使用带 Key 的版本：`remember(userId) { loadUser(userId) }`。这告诉 Compose：“当 userId 变的时候，请把脑子清空，重新记一下”。

---

## 3. 编码实战 (Code Lab)

**任务目标**：亲手制造“失忆”现场，然后用 `remember` 治好它。同时体验带 Key 的 `remember`。

### 步骤 1：制造失忆 (Buggy Widget)
我们做一个随机色块。

```kotlin
@Composable
fun RandomBox() {
    // 错误写法：没有 remember
    // 每次重组，Color 都会重新生成一个随机色
    val color = Color(Random.nextLong(0xFFFFFFFF))
    
    Box(modifier = Modifier.size(100.dp).background(color))
}
```

### 步骤 2：触发重组
在父组件里，我们弄个按钮疯狂触发重组。

```kotlin
@Composable
fun MemoryTest() {
    val counter = remember { mutableStateOf(0) }
    
    Column {
        Button(onClick = { counter.value++ }) { Text("重组页面: ${counter.value}") }
        
        // 我们的色块
        RandomBox()
    }
}
```
**观察**：每次点击按钮，虽然我没想动色块，但色块颜色**一直在狂闪**。因为父组件重组 -> 调用 RandomBox -> 重新生成随机色。

### 步骤 3：修复 (Fix with remember)
修改 `RandomBox`：
```kotlin
val color = remember { Color(Random.nextLong(0xFFFFFFFF)) }
```
**观察**：再次点击按钮，计数器在变，但**色块颜色稳定不动了**！因为它记住了第一次生成的颜色。

### 步骤 4：高级 (remember with Key)
现在需求变了：我们希望每点击 5 次按钮，色块才变一次色。
修改 `RandomBox`，接收一个 key。

```kotlin
@Composable
fun RandomBox(key: Int) {
    // 当 key 变化时，重新计算颜色
    val color = remember(key) { Color(Random.nextLong(0xFFFFFFFF)) }
    Box(modifier = Modifier.size(100.dp).background(color))
}
```

修改父组件调用：
```kotlin
// 只有当 counter / 5 的结果变化时（即每5次），传入的参数才会变
RandomBox(key = counter.value / 5)
```
**观察**：点 1, 2, 3, 4 次，颜色不变。点第 5 次，颜色变了。
这证明了 `remember(key)` 的缓存失效机制。
恭喜你，第一章（声明式 UI 基础与布局系统）的所有核心知识点我们已经全部攻克了！

接下来我们将进入 **第二章：状态管理 (State Management)**。这是 Compose 的灵魂所在，也是从“画静态图”跨越到“做动态 App”的关键一步。

我们将从 **2.1 响应式状态基础** 开始。

---

# 2.1.1 MutableState 接口与状态创建

## 1. 核心理论：为什么普通变量“带不动”UI？

### 1.1 传统的变量 vs Compose 的变量
在 Kotlin 中，我们定义一个变量：
```kotlin
var count = 0
```
当我们执行 `count = 1` 时，内存里的值确实变了。但在 Compose 的世界里，**UI 对此一无所知**。

**原理**：
Compose 的 UI 刷新机制（重组）是**被动触发**的。它像一个在打瞌睡的画家。
*   **普通变量变化**：就像你在旁边悄悄换了模特的衣服，画家还在打瞌睡，根本没看见，所以画布上的画不会变。
*   **MutableState 变化**：就像你换衣服的同时，用力敲了一下锣。画家被惊醒了（收到通知），睁眼一看：“哎呀数据变了”，于是重新画了一遍。

### 1.2 MutableState 的魔法
`MutableState<T>` 是 Compose 提供的一个特殊的接口，它包含一个 `.value` 属性。
它的魔法在于：
1.  **读取时 (.value)**：Compose 会记个小本本 —— “在这个函数里，有人读了这个变量”。这叫**订阅 (Subscription)**。
2.  **写入时 (.value = ...)**：Compose 会翻开小本本 —— “之前谁读过这个变量？通知它们重新执行！” 这叫**通知 (Notification)**。

### 1.3 创建状态的工厂：mutableStateOf
我们使用 `mutableStateOf(default_value)` 来创建一个 State 对象。
```kotlin
val countState = mutableStateOf(0) // 这是一个 State<Int> 对象
```
*   读：`countState.value`
*   写：`countState.value = 1`

这样，任何读取了 `countState.value` 的 UI 组件，都会在它变化时自动刷新。

---

## 2. 知识测验 (Quiz)

### 问题 1 [代码诊断]
阅读以下代码，判断点击按钮后会发生什么。

```kotlin
@Composable
fun BrokenCounter() {
    // 定义一个普通变量
    var count = 0

    Column {
        Text("当前数字: $count")
        Button(onClick = {
            count++ // 修改变量
            println("Log: count is now $count")
        }) {
            Text("加一")
        }
    }
}
```

A. 屏幕上的数字变成 1，控制台打印 "Log: count is now 1"。
B. 屏幕上的数字保持 0，控制台打印 "Log: count is now 1"。
C. 屏幕和控制台都没反应。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：
> *   **控制台**：代码逻辑是正常的，`count` 确实变成了 1，所以 Log 会打印。
> *   **屏幕**：因为 `count` 只是普通 Int，它没有“敲锣”通知 Compose 系统。Compose 以为数据没变，所以**没有触发重组 (Recomposition)**。Text 组件依然显示旧的 0。

### 问题 2 [原理辨析]
`MutableState` 是如何知道该通知哪些组件刷新的？

A. 它会通知全屏幕所有的组件刷新。
B. 它会通知所有写了 `@Composable` 注解的函数刷新。
C. 它利用“读取即订阅”机制，只通知那些真正**读取了它 value** 的函数刷新。

> **答案：C**
> **解析**：这是 Compose 高效的原因。**细粒度更新**。如果你只在页面的一个小角落读了这个 State，那么全屏其他部分都不会重绘，只有那个小角落会重绘。

---

## 3. 编码实战 (Code Lab)

**任务目标**：修复上面的 `BrokenCounter`，让它能真正动起来。

### 步骤 1：创建组件
在 `MainActivity.kt` 中定义 `WorkingCounter`。

### 步骤 2：使用 State
将普通的 `var count = 0` 替换为 `mutableStateOf`。
**注意**：这里还需要配合 `remember` 使用（这是下一节的重点，但为了让代码能跑，我们先机械地加上）。如果不加 `remember`，每次重组 count 又会变回 0。我们先加上，下节课详细解释为什么。

```kotlin
@Composable
fun WorkingCounter() {
    // 1. 使用 mutableStateOf 创建状态
    // remember 的作用是：在 UI 刷新时，不要丢掉这个变量，把它记下来
    val countState = remember { mutableStateOf(0) }

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.padding(16.dp)
    ) {
        // 2. 读取状态 (.value)
        // 这一行读取操作，让当前组件“订阅”了 countState
        Text(
            text = "当前数字: ${countState.value}",
            style = MaterialTheme.typography.headlineMedium
        )
        
        Spacer(modifier = Modifier.height(10.dp))

        Button(onClick = {
            // 3. 修改状态 (.value)
            // 这一行写入操作，触发了重组
            countState.value++
        }) {
            Text("加一")
        }
    }
}
```

### 步骤 3：运行与观察
1.  运行 App。
2.  点击“加一”按钮。
3.  **观察**：屏幕上的数字从 0 变成了 1，然后是 2...
4.  **思考**：你没有写任何 `textView.setText()` 的代码。你只是改了一个变量的值。UI 自己就变了。这就是**响应式编程**。

### 预告
你可能会觉得 `countState.value` 这种写法有点啰嗦，每次都要写 `.value`。
Kotlin 有一种很优雅的语法糖叫 **属性委托 (Property Delegation)**，也就是 `by` 关键字。
下一小节 2.1.2，我们就来学习如何让代码变得更简洁。
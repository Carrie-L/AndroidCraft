欢迎来到第四章！前面我们学会了如何画 UI (Layout) 和如何动 UI (State)。现在我们要解决一个更现实的问题：**如何跟这个世界交互**。
比如：发网络请求、读写数据库、弹 Toast、定时器。这些统称为“副作用”。

---

# 4.1.1 副作用概念与受控执行 (LaunchedEffect)

## 1. 核心理论：在“疯狂”的重组中寻找“安宁”

### 1.1 什么是“副作用” (Side Effect)？
在函数式编程中，如果一个函数除了返回值之外，还做了别的事（比如修改了全局变量、打印了日志、发起了一个网络请求），这就叫**副作用**。

在 Compose 中，Composable 函数应该是**纯函数**（Pure Function）：
> `UI = f(State)`
> 给定相同的 State，它应该永远只生成相同的 UI，而不产生其他影响。

### 1.2 为什么不能直接写协程？
初学者最容易犯的错误：

```kotlin
@Composable
fun UserProfile(userId: String) {
    // 错误示范：直接在函数体里写逻辑
    val scope = rememberCoroutineScope()
    scope.launch { 
        api.fetchUser(userId) // 发起网络请求
    }
    
    Text("User Page")
}
```

**后果**：
Composable 函数可能会被**非常频繁地执行**（重组）。
*   比如用户手指滑动列表，每一帧都可能触发重组。
*   如果你直接把网络请求写在函数体里，意味着**每一帧都会发起一次网络请求**！你的服务器瞬间会被打爆，App 也会因为内存耗尽而崩溃。

### 1.3 `LaunchedEffect`：安全的避风港
为了解决这个问题，Compose 提供了 `LaunchedEffect`。它是一个特殊的 Composable 函数，专门用来在 Compose 的世界里启动协程。

它的魔法在于：
1.  **生命周期感知**：它只在 Composable **首次进入**界面（Enter Composition）时启动协程。
2.  **自动取消**：当 Composable **离开**界面（Leave Composition）时，它会自动取消协程。
3.  **受控重启 (Key)**：你可以给它传一个或多个 `key`。
    *   如果 `key` 没变，重组时它**不会**重新执行。
    *   如果 `key` 变了（比如 `userId` 变了），它会**取消旧协程，启动新协程**。

这正是我们处理网络请求、定时器所需要的完美机制。

---

## 2. 知识测验 (Quiz)

### 问题 1 [代码审查]
阅读以下代码，判断日志 "Hello" 会被打印几次？

```kotlin
@Composable
fun Test() {
    var count by remember { mutableStateOf(0) }
    
    // 每次点击，count + 1，触发重组
    Button(onClick = { count++ }) { Text("Add") }

    // 这里有一个副作用
    LaunchedEffect(Unit) {
        println("Hello")
    }
}
```

A. 每次点击按钮都会打印。
B. 只会在 App 刚启动显示这个界面时打印 1 次。后续点击按钮不会打印。
C. 永远不会打印。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：
> *   `LaunchedEffect` 的 key 是 `Unit`（一个永远不变的常量）。
> *   当父组件因为 `count` 变化而重组时，Compose 检查 `LaunchedEffect` 的 key，发现没变。
> *   于是 Compose **跳过**了副作用的执行。
> *   这正是我们想要的：只在进入页面时执行一次初始化逻辑。

### 问题 2 [Key 的选择]
如果你做了一个详情页 `DetailScreen(userId: String)`。你希望每当 `userId` 变化时，都重新拉取用户数据。
你的 LaunchedEffect 应该怎么写？

A. `LaunchedEffect(Unit) { fetch(userId) }`
B. `LaunchedEffect(true) { fetch(userId) }`
C. `LaunchedEffect(userId) { fetch(userId) }`

> **答案：C**
> **解析**：
> *   A 和 B 的 key 都是常量。如果 `userId` 从 "A" 变成 "B"，因为 key 没变，Compose 不会重启协程，结果显示的还是旧用户的数据。
> *   C 将 `userId` 作为 key。当 ID 变化，旧请求被取消，新请求发起。完美。

---

## 3. 编码实战 (Code Lab)

**任务目标**：制作一个“闪屏页 (Splash Screen)”。
要求：
1.  显示“欢迎来到 Jetpack Compose”。
2.  等待 2 秒钟。
3.  自动跳转到主页（这里用回调模拟跳转）。
4.  （验证点）如果在 2 秒内用户退出了界面，倒计时应该自动取消，不触发跳转。

### 步骤 1：定义闪屏组件
这个组件接收一个 `onTimeout` 回调，用于通知父组件“时间到了”。

```kotlin
@Composable
fun SplashScreen(onTimeout: () -> Unit) {
    // 1. 定义状态，仅用于显示倒计时文本（可选优化）
    // 这里我们简单点，只显示静态文字
    
    // 2. 启动副作用
    // Key = Unit，表示只在进入时执行一次
    LaunchedEffect(Unit) {
        println("计时开始...")
        delay(2000) // 挂起 2 秒，模拟耗时操作
        println("计时结束，准备跳转")
        // 时间到，执行回调
        onTimeout()
    }

    // UI 部分
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text("欢迎来到 Jetpack Compose", style = MaterialTheme.typography.headlineMedium)
    }
}
```

### 步骤 2：模拟主界面与切换
在 `MainActivity` 中，我们要模拟“从闪屏页切到主页”的过程。

```kotlin
@Composable
fun AppNavigation() {
    // 使用一个状态来控制当前显示哪个页面
    // true = 显示闪屏，false = 显示主页
    var showSplash by remember { mutableStateOf(true) }

    if (showSplash) {
        SplashScreen(onTimeout = { 
            // 倒计时结束，切换状态
            showSplash = false 
        })
    } else {
        // 主页内容
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("这里是主页")
        }
    }
}
```

### 步骤 3：运行与验证
1.  **正常流程**：运行 App。看到“欢迎”文字。2秒后，自动变成“这里是主页”。
2.  **取消流程验证**：
    *   稍微修改代码，把 delay 改长一点（比如 5000ms），方便操作。
    *   运行 App，显示闪屏页。
    *   **立刻按 Home 键**（或者在 Android Studio 的 Logcat 里杀掉进程/退出 Activity）。
    *   观察 Logcat：你会发现 "计时开始..." 打印了，但 "计时结束..." **没有打印**。
    *   **原理**：当你退出 Activity 时，`SplashScreen` 离开了 Composition。`LaunchedEffect` 自动取消了内部正在 `delay` 的协程。这证明了它是**生命周期安全**的，不会导致内存泄漏或崩溃。
这是 **2.4.2 状态提升 (State Hoisting)** 的详细知识讲解。

这是 UDF 模式在实际编码中的具体操作手法。如果你不想在每个组件里都写一遍 `remember { mutableStateOf(...) }`，或者你想让两个不相干的组件联动，就必须掌握这一招。

---

# 2.4.2 状态提升 (State Hoisting)

## 1. 核心理论：把控制权交出去

### 1.1 什么是状态提升？
**State Hoisting** 是指将状态从组件内部（Internal State）移动到组件的调用者（Caller）那里的过程。

*   **提升前（有状态 Stateful）**：组件自己管理数据，自己玩自己的。
    *   优点：调用简单，不需要传参。
    *   缺点：外部没法控制它，也没法复用它。
*   **提升后（无状态 Stateless）**：组件把数据通过参数要进来，把事件抛出去。
    *   优点：完全受控，极易复用和测试。
    *   缺点：调用时参数变多了。

### 1.2 什么时候需要提升？
有一个黄金法则：**当状态需要被多个组件共享，或者需要被外部控制时，就提升它。**

**经典场景：两个 Slider 联动**
假设你有两个滑块，Slider A 和 Slider B。你希望拖动 A 的时候，B 也跟着动（保持同步）。
*   如果 A 和 B 各自维护自己的 `progress`，它们是无法通信的。
*   **解决**：把 `progress` 状态从 A 和 B 里面拿出来，放到它们的父组件 `Column` 里。父组件把同一个 `progress` 传给 A 和 B。这就是“状态提升”。

### 1.3 提升的标准模式
将状态提升后的组件函数签名通常长这样：
```kotlin
@Composable
fun MyWidget(
    value: T,              // 当前值
    onValueChange: (T) -> Unit  // 改变值的请求
)
```
这种 `(value, onValueChange)` 的模式在 Compose 标准库中随处可见（如 `TextField`, `Slider`, `Checkbox`）。

---

## 2. 知识测验 (Quiz)

### 问题 1 [代码重构]
下面是一个自带状态的搜索框组件：
```kotlin
@Composable
fun SearchBar() {
    var text by remember { mutableStateOf("") } // 内部状态
    TextField(value = text, onValueChange = { text = it })
}
```
现在，你需要实现一个功能：点击屏幕右上角的“清空”按钮，要把这个搜索框的内容清空。
请问：上面的 `SearchBar` 能直接满足需求吗？

A. 能，直接调用 SearchBar.clear() 方法。
B. 不能，因为 `text` 状态被封死在函数内部了，外部无法修改它。必须进行状态提升。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：Composable 函数没有“对象实例”，也没有方法可调。一旦状态写在里面，外部就完全失控了。
> *修正*：`fun SearchBar(text: String, onTextChange: (String) -> Unit)`。

### 问题 2 [设计权衡]
既然无状态组件那么好，我们是不是应该把所有的状态都提升到最顶层（Activity/Screen）？

A. 是的，这样最整洁。
B. 不是，只提升那些“需要被共享或控制”的状态。如果一个状态只有组件自己关心（比如按键按下的水波纹动画、列表滑动的偏移量），应该留在组件内部。

> **答案：B**
> **解析**：过度提升会导致父组件参数爆炸（Prop Drilling 问题），且父组件逻辑过于臃肿。架构设计的精髓在于**“适度”**。

---

## 3. 编码实战 (Code Lab)

**任务目标**：实现“同步进度条”。体验状态提升解决组件通信问题的能力。

### 步骤 1：编写无状态的 Slider 组件
这个组件本身不保存进度，只负责显示和汇报拖动事件。

```kotlin
@Composable
fun StatelessSlider(
    value: Float,             // 接收当前进度
    onValueChange: (Float) -> Unit // 汇报进度变化
) {
    Column {
        Text("当前值: ${(value * 100).toInt()}%")
        Slider(
            value = value,
            onValueChange = onValueChange
        )
    }
}
```

### 步骤 2：在父组件中管理共享状态
我们创建两个 `StatelessSlider`，并把同一个 State 传给它们。

```kotlin
@Composable
fun SyncedSliders() {
    // 1. 状态提升到了这里（父组件）
    // 这是两个子组件的“共同祖先”
    var sharedProgress by remember { mutableStateOf(0.5f) }

    Column(modifier = Modifier.padding(16.dp)) {
        Text("同步控制面板", style = MaterialTheme.typography.headlineSmall)
        
        Spacer(modifier = Modifier.height(20.dp))

        // 滑块 A
        Text("滑块 A")
        StatelessSlider(
            value = sharedProgress, // 数据下行
            onValueChange = { sharedProgress = it } // 事件上行
        )

        Spacer(modifier = Modifier.height(20.dp))

        // 滑块 B
        Text("滑块 B (跟 A 一样)")
        StatelessSlider(
            value = sharedProgress, // 关键：传的是同一个 state
            onValueChange = { sharedProgress = it }
        )
    }
}
```

### 步骤 3：运行与验证
1.  运行 App。
2.  拖动“滑块 A”。
3.  **观察**：“滑块 B” 也会跟着一起动，进度完全同步。
4.  **原理**：
    *   A 拖动 -> 调用 `onValueChange` -> 父组件 `sharedProgress` 更新。
    *   父组件重组 -> 重新调用 A 和 B，传入新的 `sharedProgress`。
    *   A 和 B 同时刷新 UI。

这就是通过**状态提升**实现组件间通信的标准范式。至此，你已经掌握了 Compose 状态管理的精髓！
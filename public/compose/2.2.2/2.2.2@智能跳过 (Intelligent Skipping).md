
# 2.2.2 智能跳过 (Intelligent Skipping)

## 1. 核心理论：信任危机

### 1.1 为什么 Compose 也是“懒”的？
重组是一个递归过程。父组件重组时，逻辑上子组件也会被调用。
但如果子组件很复杂（比如画一张复杂的图表），每次父组件变一点小数据（比如改了个背景色）都要重画图表，那 App 肯定会卡顿。

所以 Compose 运行时采用了**“激进的跳过策略”**：
**只要我看你的参数没变，我就不执行你。**

### 1.2 怎么定义“没变”？（稳定性 Stability）
这就是核心难点。
对于计算机来说，判断 `1 == 1` 很简单。但判断 `User(name="A") == User(name="A")` 就复杂了。

Compose 定义了三种稳定性状态：
1.  **Stable (稳定)**：
    *   在这个类中，如果公开属性变了，Compose **一定能收到通知**。
    *   或者，这个类是**不可变**的（Immutable）。
    *   **例子**：`String`, `Int`, `data class User(val name: String)`。

2.  **Unstable (不稳定)**：
    *   这个类的属性可能会变，而且变了 Compose **不知道**。
    *   **例子**：普通 `class`（带有 `var`），或者 `List/Map` 接口（因为 List 可能是 MutableList，Compose 无法保证它内部数据没被偷偷改掉）。
    *   **后果**：**永远不跳过**。哪怕你觉得没变，Compose 为了保险，每次都会重组它。

### 1.3 常见的“坑”：List
最著名的坑就是 `List`。
```kotlin
@Composable
fun UserList(users: List<String>) { ... }
```
即使你传给它同一个 List 对象，Compose 也会认为它是 **Unstable** 的。
因为 `List` 是一个接口，它背后的实现可能是 `ArrayList`。外部代码可能偷偷调用 `list.add("New")`，而 List 对象的引用地址没变。Compose 无法追踪这种变化，所以它选择**“宁可错杀一千（重组），不可放过一个（漏刷新）”**。

---

## 2. 知识测验 (Quiz)

### 问题 1 [代码分析]
```kotlin
data class User(var name: String) // 注意是 var

@Composable
fun Profile(user: User) {
    Text(user.name)
}
```
父组件重组时，传给 `Profile` 的 `user` 对象引用没变。请问 `Profile` 会被跳过吗？

A. 会跳过，因为 user 对象引用没变。
B. 不会跳过，因为 User 类包含 `var`，被视为 Unstable。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：因为 `name` 是 `var`，它可以在 Compose 不知道的情况下被外部修改。Compose 不信任这种对象，所以标记为 Unstable，**失去了跳过优化的能力**。
> *修正方法*：把 `var` 改成 `val`，或者在该类上加 `@Stable` 注解（承诺你会负责通知变化）。

### 问题 2 [性能优化]
如何让接收 `List<String>` 的组件也能享受“智能跳过”？

A. 没法办，List 永远是不稳定的。
B. 使用 Kotlin 的 `ImmutableList` (来自 kotlinx.collections.immutable 库) 或者定义一个包装类并标注 `@Immutable`。
C. 祈祷 Compose 变聪明。

> **答案：B**
> **解析**：如果你使用不可变集合，或者用一个 `@Immutable data class UserListWrapper(val list: List<String>)` 包裹它，Compose 就会信任这个参数，开启跳过优化。

---

## 3. 编码实战 (Code Lab)

**任务目标**：模拟“不稳定性”导致的无谓重组，并修复它。

### 步骤 1：制造问题 (Unstable List)
定义一个接收 `List` 的组件。

```kotlin
// 一个普通的接收 List 的组件
@Composable
fun BadListWidget(list: List<String>) {
    // 打日志，观察是否重组
    SideEffect { println("BadListWidget 重组了! (List大小: ${list.size})") }
    
    Column {
        list.forEach { Text(it) }
    }
}
```

### 步骤 2：测试场景
在父组件中，我们只改变一个完全不相关的变量（比如 `count`），看看 `BadListWidget` 会不会躺枪。

```kotlin
@Composable
fun StabilityTest() {
    var count by remember { mutableStateOf(0) }
    // 定义一个永远不变的 List
    val staticList = remember { listOf("A", "B", "C") }

    Column {
        Button(onClick = { count++ }) { Text("点击刷新父组件: $count") }
        
        // 传入不变的 List
        BadListWidget(list = staticList)
    }
}
```

### 步骤 3：运行与观察
1.  点击按钮。
2.  **现象**：虽然 `staticList` 内容完全没变，引用也没变，但你会发现 Logcat 里一直在打印 "BadListWidget 重组了!"。
3.  **原因**：Compose 认为 `List` 接口是不稳定的，所以不敢跳过。

### 步骤 4：修复问题 (Wrapper)
我们用一个简单的包装类来“骗”过 Compose（或者说给 Compose 一个承诺）。

```kotlin
// 声明这个类是不可变的
@androidx.compose.runtime.Immutable
data class ListWrapper(val list: List<String>)

@Composable
fun GoodListWidget(wrapper: ListWrapper) {
    SideEffect { println("GoodListWidget 重组了!") }
    Column {
        wrapper.list.forEach { Text(it) }
    }
}
```

修改父组件，把 `BadListWidget` 换成 `GoodListWidget`。
再次运行。
**现象**：点击按钮，Log 不再打印了！
**结论**：通过 `@Immutable` 契约，我们成功恢复了组件的智能跳过能力。

*(注：在实际开发中，如果你不想写 Wrapper，可以使用 kotlinx-collections-immutable 库，或者等待未来 Compose 版本的优化，但原理是一样的)*
这是 **2.3.2 配置变更持久化 (rememberSaveable)** 的详细知识讲解。

我们刚治好了组件在“重组”时的失忆症，但还有一个更严重的健忘症没治 —— **Activity 销毁重建**。这是 Android 开发者的老朋友，也是新手的噩梦。

---

# 2.3.2 配置变更持久化 (rememberSaveable)

## 1. 核心理论：跨越生死的记忆

### 1.1 什么是“配置变更” (Configuration Change)？
在 Android 中，当你做以下操作时：
*   **旋转屏幕**（从竖屏变横屏）。
*   **切换系统主题**（从亮色变深色）。
*   **更改系统语言**。
*   或者系统内存不足杀死了你的后台应用。

系统默认的行为是：**彻底销毁当前的 Activity，然后立刻创建一个新的 Activity**。
这意味着：**所有的内存变量都会被清空**。

### 1.2 `remember` 的局限性
`remember` 的记忆存储在 **Slot Table** 中，而 Slot Table 存储在 **Composition** 中，Composition 又是依附于 **Activity** 的。
所以：
*   **Activity 死了 -> Composition 销毁 -> Slot Table 清空 -> `remember` 的数据全部丢失。**

如果你只用 `remember` 记住了用户输入的文本，旋转屏幕后，文本框就空了。用户会想砸手机。

### 1.3 救星：`rememberSaveable`
`rememberSaveable` 的 API 用法和 `remember` 几乎一样，但底层逻辑完全不同。
它利用了 Android 的 **`onSaveInstanceState` (Bundle)** 机制。

1.  **保存**：当 Activity 即将销毁时，Compose 会自动把 `rememberSaveable` 中的数据序列化，塞进系统的 `Bundle` 里。
2.  **恢复**：当 Activity 重建时，Compose 会从 `Bundle` 里把数据取出来，通过 `remember` 机制还给你。

### 1.4 存储类型的限制
因为 `Bundle` 不是什么都能存的，所以 `rememberSaveable` 只能自动存储以下类型：
*   基本类型 (Int, Boolean, String...)。
*   实现了 `Parcelable` 接口的对象。
*   实现了 `Serializable` 接口的对象。

如果你想存一个普通的 Kotlin 类（比如 `User`），你需要：
1.  给它加上 `@Parcelize` 注解并实现 `Parcelable`。
2.  或者编写自定义的 `Saver`（比较高级，暂不展开，知道有这回事就行）。

---

## 2. 知识测验 (Quiz)

### 问题 1 [场景模拟]
用户正在填写一个很长的注册表单。你使用 `remember { mutableStateOf("") }` 来保存用户输入的姓名。
用户填到一半，突然切换了手机的“深色模式”（导致 Activity 重建）。
结果会怎样？

A. 姓名依然还在，用户体验良好。
B. 姓名清空了，用户需要重新输入。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：`remember` 无法跨越 Activity 的销毁重建。必须换成 `rememberSaveable`。

### 问题 2 [类型检查]
以下哪种代码会导致运行时崩溃（Crash）？

A. `val name = rememberSaveable { mutableStateOf("Alice") }`
B. `val age = rememberSaveable { mutableStateOf(25) }`
C. `val socket = rememberSaveable { mutableStateOf(Socket()) }` // Socket 是网络连接对象

> **答案：C**
> **解析**：`Socket` 对象既不是基本类型，也没有实现 `Parcelable`。Android 的 `Bundle` 无法序列化它。运行时会抛出 `IllegalArgumentException: ... cannot be saved to a Bundle`。
> *注：对于这种非 UI 状态的对象，通常也不应该保存在 UI 层，而应该放在 ViewModel 里。*

---

## 3. 编码实战 (Code Lab)

**任务目标**：制作一个“防抖”计数器。对比 `remember` 和 `rememberSaveable` 的区别。

### 步骤 1：编写对比组件
我们需要两个计数器，一个健忘，一个记性好。

```kotlin
@Composable
fun SaveableTest() {
    // 1. 普通记忆：只防重组，不防销毁
    var normalCount by remember { mutableStateOf(0) }
    
    // 2. 超级记忆：防销毁
    var savedCount by rememberSaveable { mutableStateOf(0) }

    Column(modifier = Modifier.padding(16.dp)) {
        Text("普通计数 (remember): $normalCount")
        Button(onClick = { normalCount++ }) { Text("普通 +1") }
        
        Spacer(modifier = Modifier.height(20.dp))
        
        Text("持久计数 (rememberSaveable): $savedCount")
        Button(onClick = { savedCount++ }) { Text("持久 +1") }
    }
}
```

### 步骤 2：运行与操作
1.  运行 App。
2.  把两个计数器都点到 **5**。
3.  **操作**：旋转屏幕（模拟器上有旋转按钮，或者在真机上打开自动旋转倒过来）。
    *   *注：如果不想旋转，可以在开发者选项里打开“不保留活动 (Don't keep activities)”模拟后台被杀，然后按 Home 键再回来。*

### 步骤 3：观察结果
*   **普通计数**：变回了 **0**。
*   **持久计数**：依然是 **5**。

这就是 **`rememberSaveable`** 的核心价值。
**最佳实践**：对于任何用户输入的数据（文本框内容、复选框状态、滚动位置），只要是丢失了会让用户不爽的，都应该优先考虑使用 `rememberSaveable`。
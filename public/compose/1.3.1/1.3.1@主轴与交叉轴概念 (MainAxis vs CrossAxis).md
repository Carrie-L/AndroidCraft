## 1. 核心理论：相对坐标系

### 1.1 为什么要有“轴”的概念？
在传统的绝对坐标系中，我们说“X轴”和“Y轴”。这很简单，X 永远是横的，Y 永远是竖的。

但在 Flexbox（弹性布局，Row/Column 的底层逻辑）的设计哲学里，坐标系是**相对**的。
因为 `Row` 和 `Column` 只是**方向不同**的同一个容器。为了复用同一套对齐逻辑（比如“居中”、“两端对齐”），Compose 引入了抽象概念：**主轴 (MainAxis)** 和 **交叉轴 (CrossAxis)**。

### 1.2 定义与记忆法
*   **主轴 (MainAxis)**：容器**顺着排列子元素**的那个方向。
    *   **Row**（横着排）：主轴 = **X 轴（水平）**。
    *   **Column**（竖着排）：主轴 = **Y 轴（垂直）**。

*   **交叉轴 (CrossAxis)**：与主轴**垂直**的那个方向。
    *   **Row**：交叉轴 = **Y 轴（垂直）**。
    *   **Column**：交叉轴 = **X 轴（水平）**。

**简单记忆口诀**：
*   **Row**：主横，交竖。
*   **Column**：主竖，交横。

### 1.3 对齐属性的命名逻辑
理解了轴，你就理解了为什么属性名字这么奇怪：

*   **Arrangement (排列)**：**专门管主轴**。
    *   它控制子元素**之间**怎么分布（比如：是挤在一起，还是散开）。
    *   因为涉及多个元素之间的关系，所以叫“Arrangement（安排/排列）”。
    *   在 `Row` 里叫 `horizontalArrangement`。
    *   在 `Column` 里叫 `verticalArrangement`。

*   **Alignment (对齐)**：**专门管交叉轴**。
    *   它控制子元素在**轴线上**的位置（比如：靠上、居中、靠下）。
    *   因为在这个方向上，通常不用管元素之间的间距（那是主轴的事），只需要管这一行/列整体偏向哪边，所以叫“Alignment（对齐）”。
    *   在 `Row` 里叫 `verticalAlignment`。
    *   在 `Column` 里叫 `horizontalAlignment`。

**最容易搞混的点**：
为什么 `Row`（水平容器）里有个属性叫 `verticalAlignment`（垂直对齐）？
**解答**：因为 `Row` 的交叉轴是垂直方向。你想让一排文字在**纵向**居中，当然要设置垂直对齐。

---

## 2. 知识测验 (Quiz)

### 问题 1 [概念辨析]
在 `Column`（垂直布局）中，如果你想让所有的子元素**水平居中**显示。你应该设置哪个属性？

A. `verticalArrangement = Arrangement.Center`
B. `horizontalArrangement = Arrangement.Center`
C. `horizontalAlignment = Alignment.CenterHorizontally`
D. `verticalAlignment = Alignment.CenterVertically`

> **思考后翻看答案**
>
> **答案：C**
> **解析**：
> 1. 分析容器：`Column` 是竖着排的。
> 2. 分析目标：“水平居中”。水平方向对于 Column 来说是**交叉轴**。
> 3. 找属性：管交叉轴的是 **Alignment**。
> 4. 找方向：水平方向对应 **Horizontal**。
> 所以选 `horizontalAlignment`。
>
> *A 选项会让子元素在**垂直方向**（上下）居中。*

### 问题 2 [原理应用]
在 `Row` 中，如果你想让三个图标**均匀分布**在整个屏幕宽度上（左边一个，中间一个，右边一个）。你应该调整的是主轴还是交叉轴？

A. 主轴 (MainAxis)
B. 交叉轴 (CrossAxis)

> **答案：A**
> **解析**：
> `Row` 是横着排的，你想调整它们在横向上的间距分布。横向是 `Row` 的主轴。所以应该调整 `horizontalArrangement`。

---

## 3. 编码实战 (Code Lab)

**任务目标**：通过修改对齐属性，修复一个“歪歪扭扭”的布局。

### 步骤 1：创建一个“错误”的布局
定义 `AlignmentTest` 组件。我们想要一个**垂直**布局，里面的文字需要**水平居中**。
先写一个默认的（靠左对齐）：

```kotlin
@Composable
fun AlignmentTest() {
    // modifier.fillMaxWidth() 让 Column 占满屏幕宽度
    // 否则它宽度只会包裹文字，你就看不出居中效果了
    Column(modifier = Modifier.fillMaxWidth()) {
        Text("第一行：短")
        Text("第二行：稍微长一点")
        Text("第三行：超级超级长长长长")
    }
}
```

### 步骤 2：运行观察
你会发现文字都是**靠左对齐**的（这是 Column 交叉轴的默认行为：Start）。

### 步骤 3：修复它
现在，请修改 `Column` 的参数，添加 `horizontalAlignment`。

```kotlin
@Composable
fun AlignmentTest() {
    Column(
        modifier = Modifier.fillMaxWidth(),
        // 关键代码：设置交叉轴（水平方向）居中
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("第一行：短")
        Text("第二行：稍微长一点")
        Text("第三行：超级超级长长长长")
    }
}
```

### 步骤 4：再次观察
现在，这三行长短不一的文字，应该都完美地沿着屏幕的中轴线居中了。

**思考**：
如果此时我再加一句 `verticalArrangement = Arrangement.Center`，并且给 Column 一个固定的高度（比如 200.dp），这三行字会发生什么变化？
（它们会跑到这个 200dp 区域的**垂直中心**位置去）。

进入 1.4 节，我们终于要解开 `Modifier` 的神秘面纱了。首先要解决的是最基本的问题：**“这东西到底有多大？”**

---

# 1.4.1 尺寸与约束 (Sizing Constraints)

## 1. 核心理论：父子之间的谈判

### 1.1 约束传递机制 (Constraints Propagation)
在 Android 的 View 体系中，我们习惯说“测量 (Measure)”。但在 Compose 中，核心逻辑是**“约束 (Constraints)”**。

布局过程就像一场父子间的谈判：
1.  **父组件 (Parent)** 给子组件传一个**约束范围**（Constraints）：
    *   “儿子，你的宽度最小是 0，最大是 300；高度最小是 0，最大是 100。”
    *   `(minWidth=0, maxWidth=300, minHeight=0, maxHeight=100)`
2.  **子组件 (Child)** 根据这个范围，决定自己的**实际大小** (Size)：
    *   “爸爸，那我选宽度 150，高度 50 吧。”
    *   `(width=150, height=50)`
3.  **父组件** 接受这个大小，并把子组件**放置** (Place) 在某个位置。

**原则**：子组件的大小**绝对不能**超出父组件给的约束范围。

### 1.2 三种常见的尺寸修饰符
为了控制这个谈判过程，我们使用 Modifier：

1.  **固定大小**：`Modifier.size(50.dp)` 或 `.width(50.dp)`
    *   **含义**：子组件告诉父组件：“我不管你给什么范围，我**尽量**要 50dp。”
    *   **底层原理**：它会修改传入的约束，将 `min` 和 `max` 都强制设为 50。如果父组件给的最大值只有 30，那它最后也只能是 30（被迫妥协）。

2.  **填充父容器**：`Modifier.fillMaxSize()` / `fillMaxWidth()` / `fillMaxHeight()`
    *   **含义**：子组件说：“爸爸给的最大值是多少，我就要多少。”
    *   **底层原理**：将 `minWidth` 设置为等于 `maxWidth`，强制撑满。
    *   **参数**：`fraction`（比如 `fillMaxWidth(0.5f)`），表示只要最大宽度的一半。

3.  **包裹内容 (Wrap Content)**：(默认行为)
    *   **含义**：如果不加任何尺寸 Modifier，组件就是 Wrap Content。
    *   **原理**：根据内容（比如文字长短）计算大小，只要不超标就行。

### 1.3 链式调用的陷阱
Modifier 的顺序非常重要，因为**约束是从左到右（或从上到下）流动的**。

```kotlin
Modifier.size(100.dp).padding(10.dp)
```
vs
```kotlin
Modifier.padding(10.dp).size(100.dp)
```
这两种写法最终的视觉大小是不一样的，这部分比较绕，我们在后续的 Padding 章节会深入演示，这里先记住：**尺寸通常写在链的最前面**，比较符合直觉。

---

## 2. 知识测验 (Quiz)

### 问题 1 [数值计算]
假设屏幕宽度是 **360dp**。
你写了如下代码：

```kotlin
Box(modifier = Modifier.width(200.dp)) {
    Box(modifier = Modifier.fillMaxWidth(0.5f))
}
```
请问，内部那个子 Box 的实际宽度是多少？

A. 180dp (360 * 0.5)
B. 100dp (200 * 0.5)
C. 200dp
D. 50dp

> **思考后翻看答案**
>
> **答案：B**
> **解析**：
> 1. 父 Box 宽度被限制为 200dp。
> 2. 它传给子 Box 的约束是 `maxWidth = 200dp`。
> 3. 子 Box 说我要 `fillMaxWidth(0.5f)`，也就是父约束最大值的一半。
> 4. 200 * 0.5 = 100dp。
> **结论**：`fillMaxWidth` 是填满**父容器允许的宽度**，而不是填满屏幕。

### 问题 2 [逻辑推断]
如果你给一个组件设置了 `Modifier.width(300.dp)`，但它的父容器是一个宽度只有 `100.dp` 的 `Box`。最终这个组件的宽度是多少？

A. 300dp (子组件说了算)
B. 100dp (父容器说了算)
C. 程序崩溃

> **答案：B**
> **解析**：**父容器的约束是硬性红线**。虽然你想要 300，但父容器最大只能给 100。在 Compose 中，子组件会被强制压缩到 100dp。这叫“Coerced（强制约束）”。

---

## 3. 编码实战 (Code Lab)

**任务目标**：制作一个“比例横幅”。
我们需要一个 Box，它的宽度必须总是占屏幕宽度的 **80%**，高度固定为 **100dp**，并且背景是红色的。

### 步骤 1：编写代码
在 `MainActivity` 中：

```kotlin
@Composable
fun SizingLab() {
    // 为了看清效果，我们先放一个全屏的灰色背景
    Box(
        modifier = Modifier.fillMaxSize().background(Color.LightGray),
        contentAlignment = Alignment.Center // 让内容居中，方便看
    ) {
        // 目标组件
        Box(
            modifier = Modifier
                .fillMaxWidth(0.8f) // 关键：占据父容器（屏幕）宽度的 80%
                .height(100.dp)     // 关键：高度固定
                .background(Color.Red)
        ) {
            Text("80% Width", modifier = Modifier.align(Alignment.Center))
        }
    }
}
```

### 步骤 2：运行与验证
运行 App。
1.  你会看到屏幕中间有一个红色的条。
2.  这个红条并没有填满屏幕宽度，左右两边留有灰色的空隙。
3.  如果你旋转屏幕（或者换个平板模拟器），你会发现红条变长了，但它**永远占据屏幕宽度的 80%**。

这就是响应式布局的基础——**使用比例 (`fillMaxWidth(fraction)`) 而不是写死 `width(300.dp)`**。
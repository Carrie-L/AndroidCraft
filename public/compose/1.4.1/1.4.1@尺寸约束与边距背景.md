
## 1. 尺寸与约束：父子之间的谈判

### 1.1 约束传递机制 (Constraints Propagation)
在 Android 的 View 体系中，我们习惯说“测量 (Measure)”。但在 Compose 中，核心逻辑是**“约束 (Constraints)”**。

布局过程就像一场父子间的谈判：
1.  **父组件 (Parent)** 给子组件传一个**约束范围**（Constraints）：
    *   “儿子，你的宽度最小是 0，最大是 300；高度最小是 0，最大是 100。”
    *   `(minWidth=0, maxWidth=300, minHeight=0, maxHeight=100)`
2.  **子组件 (Child)** 根据这个范围，决定自己的**实际大小** (Size)：
    *   “爸爸，那我选宽度 150，高度 50 吧。”
    *   `(width=150, height=50)`
3.  **父组件** 接受这个大小，并把子组件**放置** (Place) 在某个位置。

**原则**：子组件的大小**绝对不能**超出父组件给的约束范围。

### 1.2 三种常见的尺寸修饰符
为了控制这个谈判过程，我们使用 Modifier：

1.  **固定大小**：`Modifier.size(50.dp)` 或 `.width(50.dp)`
    *   **含义**：子组件告诉父组件：“我不管你给什么范围，我**尽量**要 50dp。”
    *   **底层原理**：它会修改传入的约束，将 `min` 和 `max` 都强制设为 50。如果父组件给的最大值只有 30，那它最后也只能是 30（被迫妥协）。

2.  **填充父容器**：`Modifier.fillMaxSize()` / `fillMaxWidth()` / `fillMaxHeight()`
    *   **含义**：子组件说：“爸爸给的最大值是多少，我就要多少。”
    *   **底层原理**：将 `minWidth` 设置为等于 `maxWidth`，强制撑满。
    *   **参数**：`fraction`（比如 `fillMaxWidth(0.5f)`），表示只要最大宽度的一半。

3.  **包裹内容 (Wrap Content)**：(默认行为)
    *   **含义**：如果不加任何尺寸 Modifier，组件就是 Wrap Content。
    *   **原理**：根据内容（比如文字长短）计算大小，只要不超标就行。

### 1.3 链式调用的陷阱
Modifier 的顺序非常重要，因为**约束是从左到右（或从上到下）流动的**。

```kotlin
Modifier.size(100.dp).padding(10.dp)
```
vs
```kotlin
Modifier.padding(10.dp).size(100.dp)
```
这两种写法最终的视觉大小是不一样的，这部分比较绕，我们在后续的 Padding 章节会深入演示，这里先记住：**尺寸通常写在链的最前面**，比较符合直觉。

---


## 2. 边距与背景：洋葱模型 (Onion Model)

### 2.1 传统的误区
在 CSS 或 Android XML 中，`margin`（外边距）和 `padding`（内边距）是两个截然不同的属性。
*   `margin`：我不挨着别人。
*   `padding`：内容不挨着我。

但在 Compose 中，**根本没有 `margin` 这个属性！**
只有 `padding`。
那你怎么实现外边距呢？答案在于：**顺序**。

### 2.2 洋葱模型原理
想象一个组件是一个核心（Content）。Modifier 就像是一层层包裹在外面的**洋葱皮**。
**代码的执行顺序决定了洋葱皮的包裹顺序。**

*   **Modifier 链式调用是从左到右（代码顺序）执行的，但在视觉上是从外向内生效的。**（这个说法可能有点绕，看下面的例子）

### 2.3 顺序的魔力
这是 Compose 布局的黄金法则：

**场景 A：先背景，后边距**
```kotlin
Modifier
    .background(Red) // 第1层皮：刷成红色
    .padding(20.dp)  // 第2层皮：加20dp厚度（透明的）
```
*   **结果**：你得到一个红色的方块，方块**内部**的内容被挤进去 20dp。
*   **视觉效果**：这看起来像 **Padding（内边距）**。

**场景 B：先边距，后背景**
```kotlin
Modifier
    .padding(20.dp)  // 第1层皮：加20dp厚度（透明的）
    .background(Red) // 第2层皮：在剩下的核心区域刷红色
```
*   **结果**：最外层是透明的 20dp，里面才是红色方块。
*   **视觉效果**：这看起来像 **Margin（外边距）**。

**总结**：
在 Compose 中，**Padding 只是修改了后续 Modifier 可用的尺寸约束**。
*   写在 `background` **后面**的 padding = 内边距。
*   写在 `background` **前面**的 padding = 外边距。



# 2.2.1 重组触发原理 (Triggering Recomposition)

## 1. 核心理论：按需刷新的艺术

### 1.1 什么是重组 (Recomposition)？
在传统 View 体系里，如果数据变了，我们可能通过 `invalidate()` 触发整个 View 树的重绘。
在 Compose 中，重组是指：**重新调用 Composable 函数以生成新的 UI 树的过程**。

但关键在于：**不是重新调用所有函数，而是只调用受影响的函数。**

### 1.2 范围失效 (Scope Invalidation)
Compose 编译器非常聪明。它在编译你的代码时，会给你的代码“打桩”。它知道哪个 State 在哪里被读取了。

**举个栗子**：
```kotlin
@Composable
fun MyScreen() {
    var count by remember { mutableStateOf(0) } // 状态源

    Column {
        Header() // 组件 A：没有读取 count
        Counter(count) // 组件 B：读取了 count
        Footer() // 组件 C：没有读取 count
    }
}
```

当 `count` 变化时：
1.  Compose 运行时发现 `count` 变了。
2.  它查看“订阅名册”，发现只有 `MyScreen`（因为变量定义在这里）和 `Counter`（因为参数传给了它）与之相关。
3.  **实际上**，Compose 甚至能做到更细粒度：
    *   `Header()`：没变，**跳过 (Skip)**。
    *   `Footer()`：没变，**跳过 (Skip)**。
    *   `Counter(count)`：参数变了，**重组 (Recompose)**。

这就是 **智能跳过**。它保证了只有真正需要更新的 UI 才会消耗 CPU。

### 1.3 快照系统 (Snapshot System)
为什么 Compose 能监听到变量变化？
底层有一个叫 **Snapshot** 的系统。
*   所有的 `State` 都是基于快照的。
*   当你修改 State 时，就像在一个数据库事务中提交了一次 Commit。
*   Compose 监听这个全局的快照提交，一旦有提交，就触发下一帧的重组。

这也是为什么你不能直接用普通变量 —— 普通变量不在快照系统的监控范围内。

---

## 2. 知识测验 (Quiz)

### 问题 1 [逻辑推断]
```kotlin
@Composable
fun Parent() {
    var count by remember { mutableStateOf(0) }
    
    Column {
        // A: 读取了 count
        Text("Count: $count") 
        
        // B: 这是一个非常耗时的复杂组件，参数是固定的
        ComplexWidget(staticTitle = "Hello") 
        
        Button(onClick = { count++ }) { Text("Add") }
    }
}
```
当点击按钮，`count` 增加时，`ComplexWidget` 会被重组吗？

A. 肯定会，因为它是 Parent 的子组件，父组件重组，子组件一定重组。
B. 可能会，取决于 `ComplexWidget` 是否“稳定 (Stable)”以及 Compose 能否成功跳过它。
C. 肯定不会，因为它没有读取 `count`。

> **思考后翻看答案**
>
> **答案：B**
> **解析**：
> *   理论上，Compose 会尽力跳过它。
> *   但前提是 Compose 确信 `staticTitle` 这个参数没变。如果参数是基本类型（String, Int），它通常能跳过。
> *   但如果参数是一个不稳定的类（比如普通的 `List` 或 `var` 属性的类），Compose 为了保险起见，**可能会被迫重组**它。
> *   （注：这就是为什么第 6 章性能优化很重要，我们要帮 Compose 确信它是可以跳过的）。

### 问题 2 [陷阱识别]
```kotlin
var globalCount = 0 // 全局普通变量

@Composable
fun Test() {
    Text("$globalCount")
    Button(onClick = { globalCount++ }) { ... }
}
```
点击按钮后，界面会刷新吗？为什么？

A. 会刷新，因为 Text 读取了 globalCount。
B. 不会刷新，因为 globalCount 不是 State，不在快照系统中，Compose 不知道它变了。

> **答案：B**
> **解析**：没有 `State` 包装，就没有通知。这是初学者最常犯的错误。

---

## 3. 编码实战 (Code Lab)

**任务目标**：通过打 Log，亲眼验证“智能跳过”现象。

### 步骤 1：编写测试组件
我们需要两个子组件：一个读状态，一个不读。

```kotlin
@Composable
fun StateReader(count: Int) {
    // 副作用：每次重组打印日志
    // SideEffect 是一个在每次重组成功后执行的 API，非常适合打 Log
    SideEffect { println("StateReader 重组了! count=$count") }
    Text("读数组件: $count")
}

@Composable
fun StaticWidget() {
    SideEffect { println("StaticWidget 重组了!") }
    Text("静态组件 (我不应该动)")
}
```

### 步骤 2：编写父容器
在 `MainActivity` 中：

```kotlin
@Composable
fun RecompositionTest() {
    var count by remember { mutableStateOf(0) }

    Column {
        Button(onClick = { count++ }) { Text("点我加 1") }
        
        // 传入变化的 State
        StateReader(count = count)
        
        // 传入不变的内容
        StaticWidget()
    }
}
```

### 步骤 3：运行与观察 Logcat
1.  运行 App，打开 Logcat，过滤 `System.out`。
2.  首次启动：你会看到两个组件都打印了“重组了”（初始化）。
3.  点击按钮：
    *   **预期**：`StateReader` 打印日志。
    *   **关键**：`StaticWidget` **不应该**打印日志！

**结论**：
Compose 成功地隔离了变化。虽然 `RecompositionTest`（父组件）本身重组了，但它聪明地发现 `StaticWidget` 的参数没变，直接复用了旧的实例，跳过了执行。这就是 Compose 高性能的秘密。

前面两个 API（`LaunchedEffect` 和 `rememberCoroutineScope`）都是用来**启动协程**的。
但并不是所有的副作用都是协程。
很多传统的 Android API（比如注册广播、添加 Listener、开启传感器）是**基于回调**的，而且它们有个共同特点：**有借有还**（注册了必须注销，否则内存泄漏）。
`DisposableEffect` 就是专门为此设计的。

---

## 1. 核心理论：有借有还，再借不难

### 1.1 什么是“清理契约”？
在 View 系统中，我们通常在 `onStart()` 里注册监听器，在 `onStop()` 里注销。
在 Compose 中，Composable 函数可能会因为重组频繁地出现和消失。我们需要一种机制，确保：
1.  当 Composable **进入**时，执行“注册”逻辑。
2.  当 Composable **离开**时，执行“注销”逻辑。

`DisposableEffect` 提供了这个结构：
```kotlin
DisposableEffect(key) {
    // 1. 进入时执行 (Setup)
    val listener = MyListener()
    manager.register(listener)

    // 2. 必须提供的清理回调 (Cleanup)
    onDispose {
        // 离开时执行
        manager.unregister(listener)
    }
}
```

### 1.2 onDispose 的执行时机
`onDispose` 是 `DisposableEffect` 代码块中**必须**调用的最后一行代码。它会在以下两种情况下执行：
1.  **组件销毁**：Composable 从 UI 树上被彻底移除时。
2.  **Key 变化**：如果 `DisposableEffect(key)` 中的 `key` 发生了变化。
    *   Compose 会**先执行旧的 `onDispose`**（清理旧状态）。
    *   **然后再执行新的 Effect 代码块**（建立新状态）。
    *   这保证了资源永远不会“双重注册”或“泄漏”。

### 1.3 典型应用场景
*   **监听系统广播**（如监听电量变化、网络变化）。
*   **监听 Activity 生命周期**。
*   **管理原生 View**（如 MapView 的 `onResume/onPause`）。
*   **注册传感器**（如重力感应）。

---

## 2. 知识测验 (Quiz)

### 问题 1 [执行顺序]
```kotlin
var userId by remember { mutableStateOf("A") }

DisposableEffect(userId) {
    println("注册: $userId")
    onDispose { println("注销: $userId") }
}
```
当 `userId` 从 "A" 变为 "B" 时，控制台的打印顺序是怎样的？

A. 注册: B -> 注销: A
B. 注销: A -> 注册: B
C. 注销: A -> 注册: A -> 注销: B -> 注册: B

> **思考后翻看答案**
>
> **答案：B**
> **解析**：这就好比换工作。你必须先从旧公司辞职（注销 A），才能去新公司入职（注册 B）。Compose 严格保证这个顺序，防止资源冲突。

### 问题 2 [API 误用]
下面这段代码有什么问题？
```kotlin
DisposableEffect(Unit) {
    val job = scope.launch { ... } // 启动一个协程
    onDispose {
        job.cancel()
    }
}
```

A. 没问题，这是标准写法。
B. 有问题，应该用 `LaunchedEffect`。
C. 有问题，`scope` 不能在 Effect 里用。

> **答案：B**
> **解析**：虽然这样写能跑，但这属于**“拿大炮打蚊子”**。
> *   `LaunchedEffect` 本质上就是封装好的 `DisposableEffect`（它内部帮你写了 `job.cancel()`）。
> *   如果你只是想管理协程，直接用 `LaunchedEffect` 更简洁、更易读。
> *   `DisposableEffect` 应该留给那些**非协程**的、需要手动清理的回调式 API。

---

## 3. 编码实战 (Code Lab)

**任务目标**：编写一个生命周期监听器。
Compose 的世界里没有 `onResume/onPause` 这种回调方法。我们需要自己造一个。

### 步骤 1：获取当前 LifecycleOwner
Compose 提供了 `LocalLifecycleOwner` 来获取当前的生命周期宿主（通常是 Activity 或 Fragment）。

### 步骤 2：编写监听逻辑
我们使用 `DisposableEffect` 来绑定观察者。

```kotlin
@Composable
fun LifecycleLogger() {
    // 1. 获取当前生命周期对象
    val lifecycleOwner = LocalLifecycleOwner.current
    
    // 2. 使用 DisposableEffect 绑定
    // key = lifecycleOwner，确保如果宿主变了（极少发生），我们会重新绑定
    DisposableEffect(lifecycleOwner) {
        // 2.1 创建观察者
        val observer = LifecycleEventObserver { source, event ->
            when (event) {
                Lifecycle.Event.ON_RESUME -> println("App Resumed (前台)")
                Lifecycle.Event.ON_PAUSE -> println("App Paused (后台)")
                else -> {} // 忽略其他事件
            }
        }

        // 2.2 注册观察者 (Effect 启动时执行)
        println("开始监听生命周期...")
        lifecycleOwner.lifecycle.addObserver(observer)

        // 2.3 清理观察者 (onDispose)
        onDispose {
            println("停止监听生命周期...")
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    // UI 部分
    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
        Text("按 Home 键切到后台试试")
    }
}
```

### 步骤 3：运行与验证
1.  运行 App。Logcat 打印 "开始监听..."。
2.  **切后台**：按下手机 Home 键。
    *   Logcat 打印 "App Paused (后台)"。
3.  **切回前台**：点击 App 图标回到应用。
    *   Logcat 打印 "App Resumed (前台)"。
4.  **退出页面**：按 Back 键退出 Activity。
    *   Logcat 打印 "停止监听生命周期..."。

**总结**：通过 `DisposableEffect`，我们成功地在 Compose 的函数式世界里，优雅地处理了传统的面向对象的生命周期回调。
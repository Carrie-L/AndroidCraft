上一节我们学习了 `LaunchedEffect`，它是“自动挡”的协程启动器（一进页面就自动跑）。
但很多时候，我们需要“手动挡”——比如用户点击按钮后才发请求。这时候就需要 `rememberCoroutineScope`。

---

## 1. 核心理论：把协程“偷渡”到回调里

### 1.1 问题场景
假设你有这样一个需求：**点击按钮，显示一个 Snackbar**。
Snackbar 的显示通常是一个**挂起函数**（`snackbarHostState.showSnackbar(...)`），因为它需要等待 Snackbar 消失后才算执行完。

**错误尝试**：
```kotlin
Button(onClick = {
    // 报错！Suspend function 'showSnackbar' should be called only from a coroutine or another suspend function
    snackbarHostState.showSnackbar("Hello") 
}) { Text("Click") }
```
**原因**：`onClick` 是一个普通的 Lambda 回调，不是挂起函数作用域。你不能直接在这里调用挂起函数。

**再次错误尝试**：
```kotlin
Button(onClick = {
    GlobalScope.launch { ... } // 极度不推荐！
}) { ... }
```
**原因**：`GlobalScope` 不受控制。如果用户点击后马上关掉页面，协程还在跑，容易导致内存泄漏或崩溃。

### 1.2 解决方案：rememberCoroutineScope
我们需要一个**绑定了当前 Composable 生命周期**的 `CoroutineScope`。
`rememberCoroutineScope()` 就是为此而生的。

*   **获取**：在 Composable 函数体中调用 `val scope = rememberCoroutineScope()`。
*   **使用**：在 `onClick` 等非挂起回调中，使用 `scope.launch { ... }`。
*   **生命周期**：
    *   当这个 Composable 依然在界面上时，Scope 处于活跃状态。
    *   当这个 Composable **离开界面**（重组移除或 Activity 销毁）时，这个 Scope 会自动调用 `cancel()`，所有由它启动的协程都会被取消。

### 1.3 对比：LaunchedEffect vs rememberCoroutineScope

| 特性 | LaunchedEffect | rememberCoroutineScope |
| :--- | :--- | :--- |
| **启动时机** | 进入 Composable 时自动启动 | 需要手动调用 `scope.launch` |
| **使用场景** | 初始化数据、定时器、状态驱动的事件 | 点击事件、动画触发、手势回调 |
| **代码位置** | 直接写在 Composable 函数体里 | 用在 `onClick` 等回调 Lambda 里 |

**口诀**：
*   **自动跑**用 `LaunchedEffect`。
*   **手动点**用 `rememberCoroutineScope`。

---

## 2. 知识测验 (Quiz)

### 问题 1 [API 选择]
你需要实现一个功能：用户点击“回到顶部”按钮，列表滚动到第 0 项。
已知 `lazyListState.animateScrollToItem(0)` 是一个挂起函数。
你应该怎么写？

A.
```kotlin
val scope = rememberCoroutineScope()
Button(onClick = { 
    scope.launch { listState.animateScrollToItem(0) }
}) { Text("Top") }
```

B.
```kotlin
var trigger by remember { mutableStateOf(false) }
if (trigger) {
    LaunchedEffect(Unit) { listState.animateScrollToItem(0); trigger = false }
}
Button(onClick = { trigger = true }) { Text("Top") }
```

C.
```kotlin
Button(onClick = { 
    listState.animateScrollToItem(0) // 直接调用
}) { Text("Top") }
```

> **思考后翻看答案**
>
> **答案：A**
> **解析**：
> *   C 肯定错，编译不过（在非协程作用域调挂起函数）。
> *   B 虽然能跑，但太啰嗦了。为了点一下按钮，还得造一个 `trigger` 状态，还要处理状态复位。这是典型的“滥用状态”。
> *   A 是标准写法。点击 -> 启动协程 -> 执行滚动。简单直接。

### 问题 2 [原理辨析]
为什么不能在 Composable 函数体里直接使用 `rememberCoroutineScope` 启动协程？
例如：
```kotlin
@Composable
fun BadUsage() {
    val scope = rememberCoroutineScope()
    // 错误示范：直接在函数体里 launch
    scope.launch { loadData() } 
}
```
这样做和直接写 `GlobalScope.launch` 有什么区别？

> **答案**：
> 这样做虽然生命周期是对的（离开页面会取消），但它违反了 **副作用受控** 原则。
> *   `BadUsage` 每次重组时，都会执行 `scope.launch`。
> *   如果重组发生 10 次，就会启动 10 个协程去 `loadData`。
> *   而 `LaunchedEffect` 有 Key 机制，可以防止重组时的重复执行。
> **结论**：`scope.launch` **只能**用在回调（Callback）里，千万别直接写在函数体里。

---

## 3. 编码实战 (Code Lab)

**任务目标**：模拟一个“点击加载”的场景。
要求：
1.  界面有一个“加载数据”的按钮。
2.  点击按钮后，按钮变为“加载中...”且不可点击（防止重复点击）。
3.  模拟 2 秒网络请求。
4.  请求结束后，弹出 Snackbar 提示“加载成功”。

> *注：为了简化，这里暂时用 Log 替代 Snackbar，或者如果你已经会用 SnackbarHost，也可以直接用。我们主要练习 Scope 的使用。*

### 步骤 1：准备状态
我们需要一个状态来控制按钮文字和可用性。

```kotlin
@Composable
fun ClickLoadDemo() {
    // 1. 获取 Scope
    val scope = rememberCoroutineScope()
    
    // 2. 简单的 UI 状态
    var isLoading by remember { mutableStateOf(false) }
    
    // Snackbar 状态 (可选，如果是简单练习可用 Toast 或 Log)
    val snackbarHostState = remember { SnackbarHostState() }

    Scaffold(
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }
    ) { padding ->
        Box(modifier = Modifier.padding(padding).fillMaxSize(), contentAlignment = Alignment.Center) {
            Button(
                enabled = !isLoading, // 加载时禁用
                onClick = {
                    // 3. 在回调中使用 Scope 启动协程
                    scope.launch {
                        isLoading = true // 切换 UI 状态
                        
                        // 模拟耗时操作 (挂起函数)
                        delay(2000) 
                        println("数据加载完毕")
                        
                        isLoading = false // 恢复 UI
                        
                        // 显示 Snackbar (挂起函数)
                        snackbarHostState.showSnackbar("加载成功！")
                    }
                }
            ) {
                Text(if (isLoading) "加载中..." else "点击加载数据")
            }
        }
    }
}
```

### 步骤 2：运行与验证
1.  运行 App。
2.  点击按钮。
3.  **观察**：
    *   按钮立刻变灰，文字变“加载中...”。
    *   等待 2 秒。
    *   Snackbar 弹出“加载成功”，按钮恢复原状。
4.  **生命周期验证**（可选）：
    *   点击按钮开始加载。
    *   在 2 秒内立刻退出当前页面（按 Back 键）。
    *   观察 Logcat：应该**不会**看到 Crash，且 Snackbar 不会弹出（因为 Scope 被取消了，协程后面的代码不会执行）。